---
title: 백준-14891-시뮬레이션-톱니바퀴
date: 2020-02-27 12:31:00
category: Algorithm
draft: false
---

[문제](https://www.acmicpc.net/problem/14891)

```cpp{3}
#include <stdio.h>
#define max 9
#define num 5
// N극은 0, S극은 1
int K, target, direction;
int ans = 0;
int circle[num][max];

void left(int target) {
	int first = circle[target][1];
	for (int i = 2; i < max; i++) {
		circle[target][i - 1] = circle[target][i];
	}
	circle[target][max - 1] = first;
	return;
}

void right(int target) {
	int last = circle[target][max-1];
	for (int i = max-1; i > 1; i--) {
		circle[target][i] = circle[target][i-1];
	}
	circle[target][1] = last;
	return;
}

void rotate(int target, int direction) {
	// 3이랑 7이랑
	int temp_direction = direction;
	bool pos = true;
	int rot[num] = { 0, };
	for (int i = 1; i < num; i++)
		rot[i] = 0;
	rot[target] = direction;
	for (int i = target; i < num-1; i++) {
		if (circle[i][3] != circle[i+1][7]) {
				if (rot[i] == 1) {
					rot[i + 1] = -1;
				}
				else if(rot[i]==-1) {
					rot[i + 1] = 1;
				}
			}
		}
	temp_direction = direction;
	pos = true;
	for (int i = target; i > 1; i--) {
		if (circle[i-1][3] != circle[i][7]) {
			if (rot[i] == 1) {
				rot[i - 1] = -1;
			}
			else if (rot[i] == -1) {
				rot[i - 1] = 1;
			}
		}
	}
	for (int i = 1; i < num; i++) {
		if (rot[i] == 1)
			right(i);
		else if (rot[i] == -1)
			left(i);
	}
}

int main() {
	for (int i = 1; i < num; i++) {
		for (int j = 1; j < max; j++) {
			scanf("%1d", &circle[i][j]);
		}
	}
	scanf("%d", &K);
	for (int i = 0; i < K; i++) {
		scanf("%d %d", &target, &direction);
		rotate(target, direction);
	}
	int n = 1;
	for (int i = 1; i < num; i++) {
		if (circle[i][1] == 1) {
			ans += n;
		}
		n *= 2;
	}
	printf("%d", ans);
}
```

- 돌리는 톱니바퀴부터 오른쪽으로, 왼쪽으로 검사
- 돌아가는 경우라면 rot[i]를 수정
- 돌아가지 않으면 rot[i]를 0으로 둔다
- 검사하자마자 돌리는게 아니라 방향만 정해놓고 나중에 한번에 돌려야 한다
